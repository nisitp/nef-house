{"remainingRequest":"/Users/nisit/sites/nef-house/node_modules/thread-loader/dist/cjs.js!/Users/nisit/sites/nef-house/node_modules/babel-loader/lib/index.js!/Users/nisit/sites/nef-house/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nisit/sites/nef-house/src/components/vue-drag-it-dude/src/components/DragItDude.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/nisit/sites/nef-house/src/components/vue-drag-it-dude/src/components/DragItDude.vue","mtime":1632148739815},{"path":"/Users/nisit/sites/nef-house/node_modules/cache-loader/dist/cjs.js","mtime":1632148781129},{"path":"/Users/nisit/sites/nef-house/node_modules/thread-loader/dist/cjs.js","mtime":1632148781707},{"path":"/Users/nisit/sites/nef-house/node_modules/babel-loader/lib/index.js","mtime":1529635966000},{"path":"/Users/nisit/sites/nef-house/node_modules/vue-loader/lib/index.js","mtime":1527860006000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/*\n * Originally made by Esvalirion\n * Modified by Jacob Watson\n * Allows for panning around a scaling image\n */\nexport default {\n  name: 'drag-it-dude',\n  props: {\n    width: {\n      type: Number,\n      default: 0\n    },\n    height: {\n      type: Number,\n      default: 0\n    },\n    parentWidth: {\n      type: Number,\n      default: 0\n    },\n    parentHeight: {\n      type: Number,\n      default: 0\n    },\n    scale: {\n      type: Number,\n      default: 1\n    },\n    top: {\n      type: Number,\n      default: 1\n    },\n    left: {\n      type: Number,\n      default: 1\n    }\n  },\n  data: function data() {\n    return {\n      shiftY: null,\n      shiftX: null,\n      intLeft: this.left,\n      intTop: this.top,\n      scrollLeft: 0,\n      scrollTop: 0,\n      tempLeft: 0,\n      tempTop: 0,\n      maxLeft: 0,\n      maxTop: 0\n    };\n  },\n  computed: {\n    isIos: function isIos() {\n      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    }\n  },\n  watch: {\n    // When scale is changed, make sure panning does not go outside bounds of image\n    scale: function scale(newValue, oldValue) {\n      var w2 = this.$el.parentNode.offsetWidth / 2;\n      var h2 = this.$el.parentNode.offsetHeight / 2;\n      this.intLeft = (this.intLeft - w2) / oldValue * newValue + w2;\n      this.intTop = (this.intTop - h2) / oldValue * newValue + h2;\n    },\n    left: function left(newValue) {\n      this.intLeft = newValue;\n      this.maxLeft = Math.min(this.maxLeft - 50, newValue);\n    },\n    top: function top(newValue) {\n      this.intTop = newValue;\n      this.maxTop = Math.min(this.maxTop - 50, newValue);\n    },\n    intLeft: function intLeft(newValue) {\n      // newLeft must be <= 0\n      // newLeft + offset must not be greater than image's width\n      if (newValue > 0) {\n        newValue = 0;\n      } else if (newValue < this.maxLeft && newValue - this.$el.parentNode.offsetWidth < -1 * this.$el.childNodes[0].offsetWidth - this.$el.childNodes[0].offsetWidth * (this.scale - 1)) {\n        newValue = Math.min(-1 * this.$el.childNodes[0].offsetWidth - this.$el.childNodes[0].offsetWidth * (this.scale - 1) + this.$el.parentNode.offsetWidth + 1, this.maxLeft);\n      }\n\n      this.$emit('update:left', newValue);\n      this.$el.scrollLeft = newValue * -1;\n      this.intLeft = newValue;\n    },\n    intTop: function intTop(newValue) {\n      // newTop must be >= 0\n      // newTop + offset must not be greater than image's height\n      if (newValue > 0) {\n        newValue = 0;\n      } else if (newValue < this.maxTop && newValue - this.$el.parentNode.offsetHeight < -1 * this.$el.childNodes[0].offsetHeight - this.$el.childNodes[0].offsetHeight * (this.scale - 1)) {\n        newValue = Math.min(-1 * this.$el.childNodes[0].offsetHeight - this.$el.childNodes[0].offsetHeight * (this.scale - 1) + this.$el.parentNode.offsetHeight + 1, this.maxTop);\n      }\n\n      this.$emit('update:top', newValue);\n      this.$el.scrollTop = newValue * -1;\n      this.intTop = newValue;\n    },\n    scrollLeft: function scrollLeft(newValue) {\n      this.$el.scrollLeft = newValue * -1;\n    },\n    scrollTop: function scrollTop(newValue) {\n      this.$el.scrollTop = newValue * -1;\n    }\n  },\n  // Functions that can be called\n  methods: {\n    handleScroll: function handleScroll(e) {\n      this.scrollTop = this.intTop = this.$el.scrollTop * -1;\n      this.scrollLeft = this.intLeft = this.$el.scrollLeft * -1;\n    },\n    // Element has become active\n    // e: event\n    hang: function hang(e) {\n      this.$emit('activated'); // If available use coordinates of click to decide starting point for drag\n      // If not available, use last known coordinates to decide\n\n      this.shiftX = typeof e.pageX != 'undefined' ? e.pageX : e.changedTouches[0].pageX;\n      this.shiftY = typeof e.pageY != 'undefined' ? e.pageY : e.changedTouches[0].pageY; // If not iOS and coordinates of click are available, characterize as mouse\n      // Otherwise, characterize as touch\n\n      if (typeof e.pageX != 'undefined' && !this.isIos) {\n        this.$el.addEventListener('mousemove', this.elementMove);\n        this.$el.addEventListener('mouseleave', this.drop);\n      } else {\n        this.$el.addEventListener('touchmove', this.elementMove);\n        this.$el.addEventListener('touchend', this.drop);\n      } // Save starting point\n\n\n      this.tempLeft = this.intLeft;\n      this.tempTop = this.intTop;\n    },\n    // Element is being dragged\n    // e: event\n    elementMove: function elementMove(e) {\n      this.$emit('dragging');\n      e.preventDefault();\n\n      if (typeof e.pageY != 'undefined') {\n        document.body.style.overflow = 'hidden';\n      } // If available use coordinates of click to decide how much to shift x/y\n      // If not available, use last known coordinates to decide\n\n\n      var x = typeof e.pageX != 'undefined' ? e.pageX : e.changedTouches[0].pageX;\n      var y = typeof e.pageY != 'undefined' ? e.pageY : e.changedTouches[0].pageY; // Decide new boundries of rectangle\n\n      this.intLeft = this.tempLeft + x - this.shiftX;\n      this.intTop = this.tempTop + y - this.shiftY;\n    },\n    // Element is dropped\n    drop: function drop() {\n      this.$emit('dropped');\n      document.body.style.overflow = null; // Stop moving image on mouse movement\n\n      this.$el.removeEventListener('mousemove', this.elementMove, false);\n      this.$el.removeEventListener('touchmove', this.elementMove, false); // End drop\n\n      this.$el.onmouseup = null;\n      this.$el.ontouchend = null;\n    },\n    center: function center() {\n      this.intTop = (this.$el.childNodes[0].offsetHeight * this.scale - this.$el.parentNode.offsetHeight) / 2 * -1;\n      this.intLeft = (this.$el.childNodes[0].offsetWidth * this.scale - this.$el.parentNode.offsetWidth) / 2 * -1;\n    }\n  },\n  mounted: function mounted() {\n    this.center();\n    this.$el.addEventListener('scroll', this.handleScroll);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.$el.removeEventListener('scroll', this.handleScroll);\n  }\n};",{"version":3,"sources":["DragItDude.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n\t<div\n\t\tclass=\"drag-it-dude\"\n\t\t@touchstart.stop=\"hang\"\n\t\t@touchend.stop=\"drop\"\n\t\t@mousedown.stop=\"hang\"\n\t\t@mouseup.stop=\"drop\"\n\t\t\n\t>\n\t\t<slot></slot>\n\t</div>\n</template>\n\n<script>\n\t/*\n\t * Originally made by Esvalirion\n\t * Modified by Jacob Watson\n\t * Allows for panning around a scaling image\n\t */\n\n\texport default {\n\t\tname: 'drag-it-dude',\n\t\tprops: {\n\t\t\twidth: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 0,\n\t\t\t},\n\t\t\theight: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 0,\n\t\t\t},\n\t\t\tparentWidth: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 0,\n\t\t\t},\n\t\t\tparentHeight: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 0,\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 1,\n\t\t\t},\n\t\t\ttop: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 1,\n\t\t\t},\n\t\t\tleft: {\n\t\t\t\ttype: Number,\n\t\t\t\tdefault: 1,\n\t\t\t}\n        },\n\n        data() {\n            return {\n                shiftY: null,\n                shiftX: null,\n                intLeft: this.left,\n                intTop: this.top,\n                scrollLeft: 0,\n                scrollTop: 0,\n                tempLeft: 0,\n                tempTop: 0,\n                maxLeft: 0,\n                maxTop: 0,\n            }\n\t\t},\n\n        computed: {\n            isIos() {\n                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n            }\n        },\n\n\t\twatch: {\n\t\t\t// When scale is changed, make sure panning does not go outside bounds of image\n\t\t\tscale(newValue, oldValue) {\n                var w2 = this.$el.parentNode.offsetWidth / 2;\n                var h2 = this.$el.parentNode.offsetHeight / 2\n\n                this.intLeft = (this.intLeft - w2) / oldValue * newValue + w2;\n                this.intTop = (this.intTop - h2) / oldValue * newValue + h2;\n            },\n            left(newValue) {\n                this.intLeft = newValue;\n                this.maxLeft = Math.min(this.maxLeft - 50, newValue);\n            },\n            top(newValue) {\n                this.intTop = newValue;\n                this.maxTop = Math.min(this.maxTop - 50, newValue);\n            },\n            intLeft(newValue) {\n                // newLeft must be <= 0\n\t\t\t\t// newLeft + offset must not be greater than image's width\n\t\t\t\tif (newValue > 0) {\n\t\t\t\t\tnewValue = 0;\n\t\t\t\t} else if (newValue < this.maxLeft && newValue - this.$el.parentNode.offsetWidth < -1 * this.$el.childNodes[0].offsetWidth - (this.$el.childNodes[0].offsetWidth * (this.scale - 1))) {\n\t\t\t\t\tnewValue = Math.min(\n                        -1 * this.$el.childNodes[0].offsetWidth - (this.$el.childNodes[0].offsetWidth * (this.scale - 1)) + this.$el.parentNode.offsetWidth + 1,\n                        this.maxLeft\n                    );\n\t\t\t\t}\n\n                this.$emit('update:left', newValue);\n                this.$el.scrollLeft = newValue * -1;\n                this.intLeft = newValue;\n            },\n            intTop(newValue) {\n                // newTop must be >= 0\n\t\t\t\t// newTop + offset must not be greater than image's height\n\t\t\t\tif (newValue > 0) {\n\t\t\t\t\tnewValue = 0;\n\t\t\t\t} else if (newValue < this.maxTop && newValue - this.$el.parentNode.offsetHeight < -1 * this.$el.childNodes[0].offsetHeight - (this.$el.childNodes[0].offsetHeight * (this.scale - 1))) {\n\t\t\t\t\tnewValue = Math.min(\n                        -1 * this.$el.childNodes[0].offsetHeight - (this.$el.childNodes[0].offsetHeight * (this.scale - 1)) + this.$el.parentNode.offsetHeight + 1,\n                        this.maxTop\n                    );\n                }\n\n                this.$emit('update:top', newValue);\n                this.$el.scrollTop = newValue * -1;\n                this.intTop = newValue;\n            },\n            scrollLeft(newValue) {\n                this.$el.scrollLeft = newValue * -1;\n            },\n            scrollTop(newValue) {\n                this.$el.scrollTop = newValue * -1;\n            }\n\t\t},\n\n\t\t// Functions that can be called\n\t\tmethods: {\n            handleScroll(e) {\n                this.scrollTop = this.intTop = this.$el.scrollTop * -1;\n                this.scrollLeft = this.intLeft = this.$el.scrollLeft * -1;\n            },\n\n\t\t\t// Element has become active\n\t\t\t// e: event\n\t\t\thang(e) {\n\t\t\t\tthis.$emit('activated');\n\n\t\t\t\t// If available use coordinates of click to decide starting point for drag\n\t\t\t\t// If not available, use last known coordinates to decide\n\t\t\t\tthis.shiftX = typeof e.pageX != 'undefined' ? e.pageX : e.changedTouches[0].pageX;\n\t\t\t\tthis.shiftY = typeof e.pageY != 'undefined' ? e.pageY : e.changedTouches[0].pageY;\n\n\t\t\t\t// If not iOS and coordinates of click are available, characterize as mouse\n\t\t\t\t// Otherwise, characterize as touch\n\t\t\t\tif (typeof e.pageX != 'undefined' && !this.isIos) {\n\t\t\t\t\tthis.$el.addEventListener('mousemove', this.elementMove);\n\t\t\t\t\tthis.$el.addEventListener('mouseleave', this.drop);\n\t\t\t\t} else {\n\t\t\t\t\tthis.$el.addEventListener('touchmove', this.elementMove);\n\t\t\t\t\tthis.$el.addEventListener('touchend', this.drop);\n                }\n                \n                // Save starting point\n                this.tempLeft = this.intLeft;\n                this.tempTop = this.intTop;\n\t\t\t},\n\n\t\t\t// Element is being dragged\n\t\t\t// e: event\n\t\t\telementMove(e) {\n\t\t\t\tthis.$emit('dragging');\n\t\t\t\te.preventDefault();\n\n\t\t\t\tif (typeof e.pageY != 'undefined') {\n\t\t\t\t\tdocument.body.style.overflow = 'hidden';\n\t\t\t\t}\n\n\t\t\t\t// If available use coordinates of click to decide how much to shift x/y\n\t\t\t\t// If not available, use last known coordinates to decide\n\t\t\t\tconst x = typeof e.pageX != 'undefined' ? e.pageX : e.changedTouches[0].pageX;\n\t\t\t\tconst y = typeof e.pageY != 'undefined' ? e.pageY : e.changedTouches[0].pageY;\n\n                // Decide new boundries of rectangle\n\t\t\t\tthis.intLeft = this.tempLeft + x - this.shiftX;\n\t\t\t\tthis.intTop = this.tempTop + y - this.shiftY;\n\t\t\t},\n\n\t\t\t// Element is dropped\n\t\t\tdrop() {\n\t\t\t\tthis.$emit('dropped');\n\t\t\t\tdocument.body.style.overflow = null;\n\n\t\t\t\t// Stop moving image on mouse movement\n\t\t\t\tthis.$el.removeEventListener('mousemove', this.elementMove, false);\n\t\t\t\tthis.$el.removeEventListener('touchmove', this.elementMove, false);\n\n\t\t\t\t// End drop\n\t\t\t\tthis.$el.onmouseup = null;\n\t\t\t\tthis.$el.ontouchend = null;\n            },\n            \n            center() {\n                this.intTop = (this.$el.childNodes[0].offsetHeight * this.scale - this.$el.parentNode.offsetHeight) / 2 * -1;\n                this.intLeft = (this.$el.childNodes[0].offsetWidth * this.scale - this.$el.parentNode.offsetWidth) / 2 * -1;\n            }\n\t\t},\n\n\t\tmounted() {\n            this.center();\n            this.$el.addEventListener('scroll', this.handleScroll);\n        },\n\n        beforeDestroy() {\n            this.$el.removeEventListener('scroll', this.handleScroll);\n        }\n\t};\n</script>\n\n<style>\n.drag-it-dude {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tz-index: 1;\n    width: 100%;\n    height: 100%;\n    overflow: scroll;\n    padding-right: 17px;\n    padding-bottom: 17px;\n}\n</style>\n"],"sourceRoot":"src/components/vue-drag-it-dude/src/components"}]}